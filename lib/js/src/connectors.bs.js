// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Reductive = require("reductive/lib/js/src/reductive.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Extension$ReductiveDevTools = require("./extension.bs.js");

function unwrap(opt, exc) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    throw exc;
  }
}

var serializeMaybeVariant = (
    function _serialize(obj, isNonRoot) {
      if(!obj){ return obj }

      if(typeof obj === 'number' && !isNonRoot){ 
        return {
          type: 'update',
          _rawValue: obj
        }
      }

      const symbols = Object.getOwnPropertySymbols(obj);
      const variantNameSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsVariant)' || String(symbol) == 'Symbol(BsPolyVar)');
      const recordSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsRecord)');
      if(variantNameSymbolIdx > -1){
        const variantName = obj[symbols[variantNameSymbolIdx]];
        return {
          ...Object.keys(obj).reduce((target, key) => ({
            ...target,
            [key != 'tag' ? 'arg_'+key : key]: _serialize(obj[key], true)
          }),{}),
          type: variantName
        }
      } else if(recordSymbolIdx > -1) {
        const keys = obj[symbols[recordSymbolIdx]];
        return keys.reduce((object, key, index) => ({
          ...object,
          [key]: _serialize(obj[index], true)
        }), {})
      } else {
        return obj
      }
    }
  );

var serializeObject = (
    function _serialize(obj) {
      if(!obj){ return obj }
      
      const symbols = Object.getOwnPropertySymbols(obj);
      const variantNameSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsVariant)' || String(symbol) == 'Symbol(BsPolyVar)');
      const recordSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsRecord)');
      if(variantNameSymbolIdx > -1){
        const variantName = obj[symbols[variantNameSymbolIdx]];
        return {
          ...Object.keys(obj).reduce((target, key) => ({
            ...target,
            [key != 'tag' ? 'arg_'+key : key]: _serialize(obj[key])
          }),{}),
          type: variantName
        }
      } else if(recordSymbolIdx > -1) {
        const keys = obj[symbols[recordSymbolIdx]];
        return keys.reduce((object, key, index) => ({
          ...object,
          [key]: _serialize(obj[index])
        }), {})
      } else {
        return obj
      }
    }
  );

var deserializeObject = (
    function _serialize(obj) {
      if(!obj){ return obj }

      return Object.keys(obj).reduce((target, key) => [
        ...target, 
        (typeof obj[key] === 'object') ? _serialize(obj[key]) : obj[key]
      ], [])
    }
  );

var deserializeVariant = (
    function _serialize(obj) {
      if(!obj){ return obj }

      // restore plain variants back (represented as numbers in js)
      if(obj.type == 'update' && obj._rawValue !== undefined){
        return obj._rawValue
      }

      let target = Object.keys(obj).filter(key => key != 'tag' && key != 'type').reduce((target, key) => [
        ...target, 
        (typeof obj[key] === 'object') ? _serialize(obj[key]) : obj[key]
      ], []);
      target.tag = obj.tag;
      return target
    }
  );

var evalMethod = ( 
    function evalMethod(action, obj) {
      if (typeof action === 'string') {
        return new Function('return ' + action).call(obj);
      }

      let interpretArg = (arg) => {
        return new Function('return ' + arg)();
      };

      let evalArgs = (inArgs, restArgs) => {
        var args = inArgs.map(interpretArg);
        if (!restArgs) return args;
        var rest = interpretArg(restArgs);
        if (Array.isArray(rest)) return args.concat.apply(args, rest);
        throw new Error('rest must be an array');
      };
    
      var args = evalArgs(action.args, action.rest);
      return new Function('...args', 'return this.' + action.name + '(...args)').apply(obj, args);
    }
  );

var retainedStates = { };

function getState(store) {
  return retainedStates[store[/* connectionId */1]];
}

function mutateState(state, store) {
  return Curry._1(store[/* component */0][/* send */3], /* `DevToolStateUpdate */Block.polyVar("DevToolStateUpdate", [
                161605709,
                state
              ]));
}

function notifyListeners(store) {
  return List.iter((function (listener) {
                return Curry._1(listener, /* () */0);
              }), store[/* listeners */2]);
}

var PayloadNotFound = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.PayloadNotFound");

var StateNotFound = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.StateNotFound");

var LiftedStateNotCachedWhileExpected = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.LiftedStateNotCachedWhileExpected");

var ConnectionNotFound = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.ConnectionNotFound");

function sweepLiftedState(devTools, liftedState, store) {
  var skippedActions = liftedState.skippedActionIds;
  var newLiftedState = $$Array.fold_left((function (newLiftedState, param) {
          var skipped = newLiftedState.skippedActionIds[0];
          var actionsById = newLiftedState.actionsById;
          var newActionsById = $$Array.fold_left((function (targetActionsById, param) {
                  var key = param[0];
                  var match = Caml_format.caml_int_of_string(key) > skipped;
                  targetActionsById[match ? String(Caml_format.caml_int_of_string(key) - 1 | 0) : key] = param[1];
                  return targetActionsById;
                }), { }, $$Array.map((function (key) {
                      return /* tuple */[
                              key,
                              actionsById[key]
                            ];
                    }), Belt_Array.keep(Object.keys(actionsById), (function (key) {
                          return Caml_format.caml_int_of_string(key) !== skipped;
                        }))));
          var computedStates = Belt_Array.keepWithIndex(newLiftedState.computedStates, (function (param, index) {
                  return index !== skipped;
                }));
          var skippedActionIds = Belt_Array.map(Belt_Array.keep(newLiftedState.skippedActionIds, (function (actionId) {
                      return actionId !== skipped;
                    })), (function (entity) {
                  var match = entity > skipped;
                  if (match) {
                    return entity - 1 | 0;
                  } else {
                    return entity;
                  }
                }));
          var stagedActionIds = Belt_Array.map(Belt_Array.keep(newLiftedState.stagedActionIds, (function (entity) {
                      return entity !== skipped;
                    })), (function (entity) {
                  var match = entity > skipped;
                  if (match) {
                    return entity - 1 | 0;
                  } else {
                    return entity;
                  }
                }));
          var currentStateIndex = newLiftedState.currentStateIndex;
          var nextActionId = newLiftedState.nextActionId;
          var match = currentStateIndex > skipped;
          var match$1 = nextActionId > skipped;
          return {
                  actionsById: newActionsById,
                  computedStates: computedStates,
                  currentStateIndex: match ? currentStateIndex - 1 | 0 : currentStateIndex,
                  nextActionId: match$1 ? nextActionId - 1 | 0 : nextActionId,
                  skippedActionIds: skippedActionIds,
                  stagedActionIds: stagedActionIds
                };
        }), Object.assign({ }, liftedState), skippedActions);
  Extension$ReductiveDevTools.send(devTools, null, newLiftedState);
  var jumpResetNeeded = $$Array.fold_left((function (jumpResetNeeded, skipped) {
          if (jumpResetNeeded) {
            return true;
          } else {
            return skipped >= liftedState.currentStateIndex;
          }
        }), false, skippedActions);
  if (jumpResetNeeded) {
    var stagedActions = newLiftedState.stagedActionIds;
    var targetState = Caml_array.caml_array_get(newLiftedState.computedStates, stagedActions.length - 1 | 0).state;
    mutateState(Curry._1(deserializeObject, targetState), store);
    return /* () */0;
  } else {
    return 0;
  }
}

var PayloadNotFound$1 = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.PayloadNotFound");

var StateNotFound$1 = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.StateNotFound");

var LiftedStateNotCachedWhileExpected$1 = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.LiftedStateNotCachedWhileExpected");

function sweepLiftedState$1(devTools, liftedState, store) {
  var skippedActions = liftedState.skippedActionIds;
  var newLiftedState = $$Array.fold_left((function (newLiftedState, param) {
          var skipped = newLiftedState.skippedActionIds[0];
          var actionsById = newLiftedState.actionsById;
          var newActionsById = $$Array.fold_left((function (targetActionsById, param) {
                  var key = param[0];
                  var match = Caml_format.caml_int_of_string(key) > skipped;
                  targetActionsById[match ? String(Caml_format.caml_int_of_string(key) - 1 | 0) : key] = param[1];
                  return targetActionsById;
                }), { }, $$Array.map((function (key) {
                      return /* tuple */[
                              key,
                              actionsById[key]
                            ];
                    }), Belt_Array.keep(Object.keys(actionsById), (function (key) {
                          return Caml_format.caml_int_of_string(key) !== skipped;
                        }))));
          var computedStates = Belt_Array.keepWithIndex(newLiftedState.computedStates, (function (param, index) {
                  return index !== skipped;
                }));
          var skippedActionIds = Belt_Array.map(Belt_Array.keep(newLiftedState.skippedActionIds, (function (actionId) {
                      return actionId !== skipped;
                    })), (function (entity) {
                  var match = entity > skipped;
                  if (match) {
                    return entity - 1 | 0;
                  } else {
                    return entity;
                  }
                }));
          var stagedActionIds = Belt_Array.map(Belt_Array.keep(newLiftedState.stagedActionIds, (function (entity) {
                      return entity !== skipped;
                    })), (function (entity) {
                  var match = entity > skipped;
                  if (match) {
                    return entity - 1 | 0;
                  } else {
                    return entity;
                  }
                }));
          var currentStateIndex = newLiftedState.currentStateIndex;
          var nextActionId = newLiftedState.nextActionId;
          var match = currentStateIndex > skipped;
          var match$1 = nextActionId > skipped;
          return {
                  actionsById: newActionsById,
                  computedStates: computedStates,
                  currentStateIndex: match ? currentStateIndex - 1 | 0 : currentStateIndex,
                  nextActionId: match$1 ? nextActionId - 1 | 0 : nextActionId,
                  skippedActionIds: skippedActionIds,
                  stagedActionIds: stagedActionIds
                };
        }), Object.assign({ }, liftedState), skippedActions);
  Extension$ReductiveDevTools.send(devTools, null, newLiftedState);
  var jumpResetNeeded = $$Array.fold_left((function (jumpResetNeeded, skipped) {
          if (jumpResetNeeded) {
            return true;
          } else {
            return skipped >= liftedState.currentStateIndex;
          }
        }), false, skippedActions);
  if (jumpResetNeeded) {
    var stagedActions = newLiftedState.stagedActionIds;
    var targetState = Caml_array.caml_array_get(newLiftedState.computedStates, stagedActions.length - 1 | 0).state;
    var state = Curry._1(deserializeObject, targetState);
    store[/* state */0] = state;
    return notifyListeners(store);
  } else {
    return 0;
  }
}

function processToogleAction(store, payload, liftedState, cachedLiftedState) {
  var skippedActions = liftedState.skippedActionIds;
  var stagedActions = liftedState.stagedActionIds;
  var computedStates = liftedState.computedStates;
  var actionsById = liftedState.actionsById;
  var id = Belt_Option.getExn(Caml_option.undefined_to_opt(payload.id));
  var idx = skippedActions.indexOf(id);
  var start = stagedActions.indexOf(id);
  var skipped = idx !== -1;
  if (start === -1) {
    return liftedState;
  } else {
    var initialIdx = start - 1 | 0;
    while(skippedActions.includes(initialIdx)) {
      initialIdx = initialIdx - 1 | 0;
    };
    var initialState = Caml_array.caml_array_get(computedStates, initialIdx).state;
    var state = Curry._1(deserializeObject, initialState);
    store[/* state */0] = state;
    $$Array.iter((function (i) {
            var stagedActionKey = String(Caml_array.caml_array_get(stagedActions, i));
            var targetAction = Belt_Option.getExn(Js_dict.get(actionsById, stagedActionKey)).action;
            var action = Curry._1(deserializeVariant, targetAction);
            Reductive.Store[/* dispatch */4](store, action);
            Caml_array.caml_array_get(computedStates, i).state = Curry._1(serializeObject, Reductive.Store[/* getState */5](store));
            return /* () */0;
          }), Belt_Array.keep(Belt_Array.range(skipped ? start : start + 1 | 0, stagedActions.length - 1 | 0), (function (i) {
                if (i === start) {
                  return true;
                } else {
                  return skippedActions.indexOf(Caml_array.caml_array_get(stagedActions, i)) === -1;
                }
              })));
    if (liftedState.currentStateIndex !== (stagedActions.length - 1 | 0)) {
      var targetState = Caml_array.caml_array_get(computedStates, liftedState.currentStateIndex).state;
      var state$1 = Curry._1(deserializeObject, targetState);
      store[/* state */0] = state$1;
      notifyListeners(store);
    }
    if (skipped) {
      skippedActions.splice(idx, 1);
    } else {
      skippedActions.push(id);
    }
    cachedLiftedState[0] = Caml_option.some(liftedState);
    return liftedState;
  }
}

function handle(connection, store, actionCreators) {
  var initialState = Reductive.Store[/* getState */5](store);
  Extension$ReductiveDevTools.init(connection, Curry._1(serializeObject, initialState));
  var cachedLiftedState = /* record */Block.record(["contents"], [undefined]);
  Extension$ReductiveDevTools.subscribe(connection, (function (action) {
          var match = action.type;
          switch (match) {
            case "ACTION" : 
                var action$1 = action;
                var store$1 = store;
                var actionCreators$1 = actionCreators;
                var payload = unwrap(Caml_option.undefined_to_opt(action$1.payload), [
                      PayloadNotFound$1,
                      "action doesn't contain payload while expected"
                    ]);
                if (actionCreators$1 !== undefined) {
                  var action$2 = Curry._2(evalMethod, payload, Caml_option.valFromOption(actionCreators$1));
                  return Reductive.Store[/* dispatch */4](store$1, action$2);
                } else {
                  return /* () */0;
                }
            case "DISPATCH" : 
                var action$3 = action;
                var devTools = connection;
                var store$2 = store;
                var initial = initialState;
                var cachedLiftedState$1 = cachedLiftedState;
                var payload$1 = unwrap(Caml_option.undefined_to_opt(action$3.payload), [
                      PayloadNotFound$1,
                      "action doesn't contain payload while expected"
                    ]);
                var devTools$1 = devTools;
                var store$3 = store$2;
                var payload$2 = payload$1;
                var action$4 = action$3;
                var initial$1 = initial;
                var cachedLiftedState$2 = cachedLiftedState$1;
                var payloadType = payload$2.type;
                var exit = 0;
                switch (payloadType) {
                  case "COMMIT" : 
                      return Extension$ReductiveDevTools.init(devTools$1, Reductive.Store[/* getState */5](store$3));
                  case "IMPORT_STATE" : 
                      var nextLiftedState = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.nextLiftedState));
                      var computedStates = nextLiftedState.computedStates;
                      var targetState = Caml_array.caml_array_get(computedStates, computedStates.length - 1 | 0).state;
                      var state = Curry._1(deserializeObject, targetState);
                      store$3[/* state */0] = state;
                      notifyListeners(store$3);
                      return Extension$ReductiveDevTools.send(devTools$1, null, nextLiftedState);
                  case "JUMP_TO_ACTION" : 
                  case "JUMP_TO_STATE" : 
                      exit = 1;
                      break;
                  case "LOCK_CHANGES" : 
                      return /* () */0;
                  case "RESET" : 
                      store$3[/* state */0] = initial$1;
                      notifyListeners(store$3);
                      return Extension$ReductiveDevTools.init(devTools$1, Reductive.Store[/* getState */5](store$3));
                  case "ROLLBACK" : 
                      var stateString = unwrap(Caml_option.undefined_to_opt(action$4.state), [
                            StateNotFound$1,
                            "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                          ]);
                      var state$1 = Curry._1(deserializeObject, JSON.parse(stateString));
                      store$3[/* state */0] = state$1;
                      notifyListeners(store$3);
                      return Extension$ReductiveDevTools.init(devTools$1, Reductive.Store[/* getState */5](store$3));
                  case "SWEEP" : 
                      var liftedState = unwrap(cachedLiftedState$2[0], [
                            LiftedStateNotCachedWhileExpected$1,
                            "liftedState hasn't been cached while expected"
                          ]);
                      sweepLiftedState$1(devTools$1, liftedState, store$3);
                      cachedLiftedState$2[0] = undefined;
                      return /* () */0;
                  case "TOGGLE_ACTION" : 
                      var stateString$1 = unwrap(Caml_option.undefined_to_opt(action$4.state), [
                            StateNotFound$1,
                            "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                          ]);
                      var liftedState$1 = JSON.parse(stateString$1);
                      Extension$ReductiveDevTools.send(devTools$1, null, processToogleAction(store$3, payload$2, liftedState$1, cachedLiftedState$2));
                      return notifyListeners(store$3);
                  default:
                    return /* () */0;
                }
                if (exit === 1) {
                  var stateString$2 = unwrap(Caml_option.undefined_to_opt(action$4.state), [
                        StateNotFound$1,
                        "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                      ]);
                  var match$1 = cachedLiftedState$2[0];
                  if (match$1 !== undefined) {
                    var liftedState$2 = Caml_option.valFromOption(match$1);
                    var actionId = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.actionId));
                    var skippedActions = liftedState$2.skippedActionIds;
                    var computedStates$1 = liftedState$2.computedStates;
                    var nonSkippedIdx = actionId;
                    while(skippedActions.includes(nonSkippedIdx)) {
                      nonSkippedIdx = nonSkippedIdx - 1 | 0;
                    };
                    var targetState$1 = Caml_array.caml_array_get(computedStates$1, nonSkippedIdx).state;
                    var state$2 = Curry._1(deserializeObject, targetState$1);
                    store$3[/* state */0] = state$2;
                  } else {
                    var state$3 = Curry._1(deserializeObject, JSON.parse(stateString$2));
                    store$3[/* state */0] = state$3;
                  }
                  return notifyListeners(store$3);
                }
                case "START" : 
                return /* () */0;
            default:
              return /* () */0;
          }
        }));
  return /* () */0;
}

function defaultOptions(connectionId) {
  return {
          name: connectionId,
          features: {
            pause: true,
            lock: false,
            persist: true,
            export: true,
            import: "custom",
            jump: true,
            skip: false,
            reorder: false,
            dispatch: true
          }
        };
}

function constructOptions(options, defaults) {
  var target = Object.assign(defaults, options);
  return Object.assign(target, {
              serialize: {
                symbol: true
              },
              features: Object.assign(target["features"], {
                    lock: false,
                    reorder: false,
                    export: true,
                    import: "custom"
                  })
            });
}

function reductiveEnhancer(options, storeCreator, reducer, preloadedState, enhancer, param) {
  var targetOptions = constructOptions(options, defaultOptions("ReductiveDevTools"));
  var devTools = Extension$ReductiveDevTools.connect(Extension$ReductiveDevTools.devToolsEnhancer, targetOptions);
  var devToolsDispatch = function (store, next, action) {
    var target = enhancer !== undefined ? Curry._3(enhancer, store, next, action) : Curry._1(next, action);
    Extension$ReductiveDevTools.send(devTools, Curry._2(serializeMaybeVariant, action, false), Curry._1(serializeObject, Reductive.Store[/* getState */5](store)));
    return target;
  };
  var store = Curry._4(storeCreator, reducer, preloadedState, devToolsDispatch, /* () */0);
  var actionCreators = targetOptions.actionCreators;
  handle(devTools, store, actionCreators === undefined ? undefined : Caml_option.some(actionCreators));
  return store;
}

var connections = { };

function register(connectionId, component, options, param) {
  var targetOptions = options !== undefined ? constructOptions(Caml_option.valFromOption(options), defaultOptions(connectionId)) : defaultOptions(connectionId);
  var devTools = Extension$ReductiveDevTools.connect(Extension$ReductiveDevTools.devToolsEnhancer, targetOptions);
  var actionCreators = targetOptions.actionCreators;
  connections[connectionId] = devTools;
  retainedStates[connectionId] = component[/* state */1];
  Extension$ReductiveDevTools.init(devTools, Curry._1(serializeObject, component[/* state */1]));
  var connection = devTools;
  var store = /* record */Block.record([
      "component",
      "connectionId"
    ], [
      component,
      connectionId
    ]);
  var actionCreators$1 = actionCreators === undefined ? undefined : Caml_option.some(actionCreators);
  var initialState = getState(store);
  Extension$ReductiveDevTools.init(connection, Curry._1(serializeObject, initialState));
  var cachedLiftedState = /* record */Block.record(["contents"], [undefined]);
  Extension$ReductiveDevTools.subscribe(connection, (function (action) {
          var match = action.type;
          switch (match) {
            case "ACTION" : 
                var action$1 = action;
                var store$1 = store;
                var actionCreators$2 = actionCreators$1;
                var payload = unwrap(Caml_option.undefined_to_opt(action$1.payload), [
                      PayloadNotFound,
                      "action doesn't contain payload while expected"
                    ]);
                if (actionCreators$2 !== undefined) {
                  return Curry._1(store$1[/* component */0][/* send */3], Curry._2(evalMethod, payload, Caml_option.valFromOption(actionCreators$2)));
                } else {
                  return /* () */0;
                }
            case "DISPATCH" : 
                var action$2 = action;
                var devTools = connection;
                var store$2 = store;
                var initial = initialState;
                var cachedLiftedState$1 = cachedLiftedState;
                var payload$1 = unwrap(Caml_option.undefined_to_opt(action$2.payload), [
                      PayloadNotFound,
                      "action doesn't contain payload while expected"
                    ]);
                var devTools$1 = devTools;
                var store$3 = store$2;
                var payload$2 = payload$1;
                var action$3 = action$2;
                var initial$1 = initial;
                var cachedLiftedState$2 = cachedLiftedState$1;
                var payloadType = payload$2.type;
                var exit = 0;
                switch (payloadType) {
                  case "COMMIT" : 
                      return Extension$ReductiveDevTools.init(devTools$1, getState(store$3));
                  case "IMPORT_STATE" : 
                      var nextLiftedState = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.nextLiftedState));
                      var computedStates = nextLiftedState.computedStates;
                      var targetState = Caml_array.caml_array_get(computedStates, computedStates.length - 1 | 0).state;
                      mutateState(Curry._1(deserializeObject, targetState), store$3);
                      return Extension$ReductiveDevTools.send(devTools$1, null, nextLiftedState);
                  case "JUMP_TO_ACTION" : 
                  case "JUMP_TO_STATE" : 
                      exit = 1;
                      break;
                  case "RESET" : 
                      mutateState(initial$1, store$3);
                      return Extension$ReductiveDevTools.init(devTools$1, getState(store$3));
                  case "ROLLBACK" : 
                      var stateString = unwrap(Caml_option.undefined_to_opt(action$3.state), [
                            StateNotFound,
                            "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                          ]);
                      mutateState(Curry._1(deserializeObject, JSON.parse(stateString)), store$3);
                      return Extension$ReductiveDevTools.init(devTools$1, getState(store$3));
                  case "SWEEP" : 
                      var liftedState = unwrap(cachedLiftedState$2[0], [
                            LiftedStateNotCachedWhileExpected,
                            "liftedState hasn't been cached while expected"
                          ]);
                      sweepLiftedState(devTools$1, liftedState, store$3);
                      cachedLiftedState$2[0] = undefined;
                      return /* () */0;
                  case "LOCK_CHANGES" : 
                  case "TOGGLE_ACTION" : 
                      return /* () */0;
                  default:
                    return /* () */0;
                }
                if (exit === 1) {
                  var stateString$1 = unwrap(Caml_option.undefined_to_opt(action$3.state), [
                        StateNotFound,
                        "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                      ]);
                  var match$1 = cachedLiftedState$2[0];
                  if (match$1 !== undefined) {
                    var liftedState$1 = Caml_option.valFromOption(match$1);
                    var actionId = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.actionId));
                    var skippedActions = liftedState$1.skippedActionIds;
                    var computedStates$1 = liftedState$1.computedStates;
                    var nonSkippedIdx = actionId;
                    while(skippedActions.includes(nonSkippedIdx)) {
                      nonSkippedIdx = nonSkippedIdx - 1 | 0;
                    };
                    var targetState$1 = Caml_array.caml_array_get(computedStates$1, nonSkippedIdx).state;
                    mutateState(Curry._1(deserializeObject, targetState$1), store$3);
                  } else {
                    mutateState(Curry._1(deserializeObject, JSON.parse(stateString$1)), store$3);
                  }
                  return /* () */0;
                }
                case "START" : 
                return /* () */0;
            default:
              return /* () */0;
          }
        }));
  return /* () */0;
}

function send(connectionId, action, state) {
  var connection = unwrap(Js_dict.get(connections, connectionId), [
        ConnectionNotFound,
        "DevTool connection(id=$connectionId) not found"
      ]);
  retainedStates[connectionId] = state;
  var exit = 0;
  if (typeof action === "number" || action[0] !== 161605709) {
    exit = 1;
  } else {
    return /* () */0;
  }
  if (exit === 1) {
    return Extension$ReductiveDevTools.send(connection, Curry._2(serializeMaybeVariant, action, false), Curry._1(serializeObject, state));
  }
  
}

exports.reductiveEnhancer = reductiveEnhancer;
exports.register = register;
exports.send = send;
/* serializeMaybeVariant Not a pure module */
