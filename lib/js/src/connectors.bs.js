// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Reductive = require("reductive/lib/js/src/reductive.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Extension$ReductiveDevTools = require("./extension.bs.js");

function unwrap(opt, exc) {
  if (opt !== undefined) {
    return Caml_option.valFromOption(opt);
  } else {
    throw exc;
  }
}

var serializeMaybeVariant = (
    function _serialize(obj, isNonRoot) {
      if(!obj){ return obj }

      /* handle plain variants */
      if(typeof obj === 'number' && !isNonRoot){ 
        return {
          type: 'update',
          _rawValue: obj
        }
      }

      const symbols = Object.getOwnPropertySymbols(obj);
      const variantNameSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsVariant)' || String(symbol) == 'Symbol(BsPolyVar)');
      const recordSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsRecord)');
      if(variantNameSymbolIdx > -1){
        const variantName = obj[symbols[variantNameSymbolIdx]];
        return {
          ...Object.keys(obj).reduce((target, key) => ({
            ...target,
            [key != 'tag' ? 'arg_'+key : key]: _serialize(obj[key], true)
          }),{}),
          type: variantName
        }
      } else if(recordSymbolIdx > -1) {
        const keys = obj[symbols[recordSymbolIdx]];
        return keys.reduce((object, key, index) => ({
          ...object,
          [key]: _serialize(obj[index], true)
        }), {})
      /**
       * handle root discriminated unions when -bs-g flag is not set
       * smilarly to plain variants
       */
      } else if(Array.isArray(obj) && !isNonRoot){
        return {
          type: 'update',
          _rawValue: obj,
          // pass tag since extension will ignore other keys inside arrays
          _variant_tag: obj.tag
        }
      } else {
        return obj
      }
    }
  );

var serializeObject = (
    function _serialize(obj) {
      if(!obj){ return obj }
      
      const symbols = Object.getOwnPropertySymbols(obj);
      const variantNameSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsVariant)' || String(symbol) == 'Symbol(BsPolyVar)');
      const recordSymbolIdx = symbols.findIndex(symbol => String(symbol) == 'Symbol(BsRecord)');
      if(variantNameSymbolIdx > -1){
        const variantName = obj[symbols[variantNameSymbolIdx]];
        return {
          ...Object.keys(obj).reduce((target, key) => ({
            ...target,
            [key != 'tag' ? 'arg_'+key : key]: _serialize(obj[key])
          }),{}),
          type: variantName
        }
      } else if(recordSymbolIdx > -1) {
        const keys = obj[symbols[recordSymbolIdx]];
        return keys.reduce((object, key, index) => ({
          ...object,
          [key]: _serialize(obj[index])
        }), {})
      } else {
        return obj
      }
    }
  );

var deserializeObject = (
    function _serialize(obj) {
      if(!obj){ return obj }

      return Object.keys(obj).reduce((target, key) => [
        ...target, 
        (typeof obj[key] === 'object') ? _serialize(obj[key]) : obj[key]
      ], [])
    }
  );

var deserializeVariant = (
    function _serialize(obj) {
      if(!obj){ return obj }

      // restore plain variants and variants when running without -bs-g flag back
      if(obj.type == 'update' && obj._rawValue !== undefined){
        let target = obj._rawValue
        if(obj._variant_tag !== undefined){
          target.tag = obj._variant_tag 
        }
        return target
      }

      let target = Object.keys(obj).filter(key => key != 'tag' && key != 'type').reduce((target, key) => [
        ...target, 
        (typeof obj[key] === 'object') ? _serialize(obj[key]) : obj[key]
      ], []);
      target.tag = obj.tag;
      return target
    }
  );

var evalMethod = ( 
    function evalMethod(action, obj) {
      if (typeof action === 'string') {
        return new Function('return ' + action).call(obj);
      }

      let interpretArg = (arg) => {
        return new Function('return ' + arg)();
      };

      let evalArgs = (inArgs, restArgs) => {
        var args = inArgs.map(interpretArg);
        if (!restArgs) return args;
        var rest = interpretArg(restArgs);
        if (Array.isArray(rest)) return args.concat.apply(args, rest);
        throw new Error('rest must be an array');
      };
    
      var args = evalArgs(action.args, action.rest);
      return new Function('...args', 'return this.' + action.name + '(...args)').apply(obj, args);
    }
  );

var connections = { };

function getState(store) {
  return connections[store[/* connectionId */1]][/* retainedState */0];
}

function mutateState(state, store) {
  return Curry._1(store[/* component */0][/* send */3], /* `DevToolStateUpdate */Block.polyVar("DevToolStateUpdate", [
                161605709,
                state
              ]));
}

function notifyListeners(store) {
  return List.iter((function (listener) {
                return Curry._1(listener, /* () */0);
              }), store[/* listeners */2]);
}

var PayloadNotFound = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.PayloadNotFound");

var StateNotFound = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.StateNotFound");

var ConnectionNotFound = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.ConnectionNotFound");

var PayloadNotFound$1 = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.PayloadNotFound");

var StateNotFound$1 = Caml_exceptions.create("Connectors-ReductiveDevTools.ConnectionHandler(Store).Exceptions.StateNotFound");

function processToogleAction(store, payload, liftedState, meta) {
  var skippedActions = liftedState.skippedActionIds;
  var stagedActions = liftedState.stagedActionIds;
  var computedStates = liftedState.computedStates;
  var actionsById = liftedState.actionsById;
  var id = Belt_Option.getExn(Caml_option.undefined_to_opt(payload.id));
  var idx = skippedActions.indexOf(id);
  var start = stagedActions.indexOf(id);
  var skipped = idx !== -1;
  if (start === -1) {
    return liftedState;
  } else {
    var initialIdx = start - 1 | 0;
    while(skippedActions.includes(initialIdx)) {
      initialIdx = initialIdx - 1 | 0;
    };
    var initialState = Caml_array.caml_array_get(computedStates, initialIdx).state;
    var state = Curry._1(deserializeObject, initialState);
    store[/* state */0] = state;
    var preservedActionCount = meta[/* actionCount */2];
    $$Array.iter((function (i) {
            var stagedActionKey = String(Caml_array.caml_array_get(stagedActions, i));
            var targetAction = Belt_Option.getExn(Js_dict.get(actionsById, stagedActionKey)).action;
            var action = Curry._1(deserializeVariant, targetAction);
            Reductive.Store[/* dispatch */4](store, action);
            Caml_array.caml_array_get(computedStates, i).state = Curry._1(serializeObject, Reductive.Store[/* getState */5](store));
            return /* () */0;
          }), Belt_Array.keep(Belt_Array.range(skipped ? start : start + 1 | 0, stagedActions.length - 1 | 0), (function (i) {
                if (i === start) {
                  return true;
                } else {
                  return skippedActions.indexOf(Caml_array.caml_array_get(stagedActions, i)) === -1;
                }
              })));
    meta[/* actionCount */2] = preservedActionCount;
    if (liftedState.currentStateIndex !== (stagedActions.length - 1 | 0)) {
      var targetState = Caml_array.caml_array_get(computedStates, liftedState.currentStateIndex).state;
      var state$1 = Curry._1(deserializeObject, targetState);
      store[/* state */0] = state$1;
      notifyListeners(store);
    }
    if (skipped) {
      skippedActions.splice(idx, 1);
    } else {
      skippedActions.push(id);
    }
    meta[/* liftedState */0] = Caml_option.some(liftedState);
    return liftedState;
  }
}

function handle(connection, store, meta, actionCreators) {
  var initialState = Reductive.Store[/* getState */5](store);
  Extension$ReductiveDevTools.init(connection, Curry._1(serializeObject, initialState));
  Extension$ReductiveDevTools.subscribe(connection, (function (action) {
          var match = action.type;
          switch (match) {
            case "ACTION" : 
                var action$1 = action;
                var store$1 = store;
                var actionCreators$1 = actionCreators;
                var payload = unwrap(Caml_option.undefined_to_opt(action$1.payload), [
                      PayloadNotFound$1,
                      "action doesn't contain payload while expected"
                    ]);
                if (actionCreators$1 !== undefined) {
                  var action$2 = Curry._2(evalMethod, payload, Caml_option.valFromOption(actionCreators$1));
                  return Reductive.Store[/* dispatch */4](store$1, action$2);
                } else {
                  return /* () */0;
                }
            case "DISPATCH" : 
                var action$3 = action;
                var devTools = connection;
                var store$2 = store;
                var initial = initialState;
                var meta$1 = meta;
                var payload$1 = unwrap(Caml_option.undefined_to_opt(action$3.payload), [
                      PayloadNotFound$1,
                      "action doesn't contain payload while expected"
                    ]);
                var devTools$1 = devTools;
                var store$3 = store$2;
                var payload$2 = payload$1;
                var action$4 = action$3;
                var initial$1 = initial;
                var meta$2 = meta$1;
                var payloadType = payload$2.type;
                var exit = 0;
                switch (payloadType) {
                  case "COMMIT" : 
                      meta$2[/* actionCount */2] = 0;
                      return Extension$ReductiveDevTools.init(devTools$1, Reductive.Store[/* getState */5](store$3));
                  case "IMPORT_STATE" : 
                      var nextLiftedState = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.nextLiftedState));
                      var computedStates = nextLiftedState.computedStates;
                      var targetState = Caml_array.caml_array_get(computedStates, computedStates.length - 1 | 0).state;
                      var state = Curry._1(deserializeObject, targetState);
                      store$3[/* state */0] = state;
                      notifyListeners(store$3);
                      meta$2[/* actionCount */2] = nextLiftedState.nextActionId - 1 | 0;
                      return Extension$ReductiveDevTools.send(devTools$1, null, nextLiftedState);
                  case "JUMP_TO_ACTION" : 
                  case "JUMP_TO_STATE" : 
                      exit = 1;
                      break;
                  case "RESET" : 
                      store$3[/* state */0] = initial$1;
                      notifyListeners(store$3);
                      meta$2[/* actionCount */2] = 0;
                      return Extension$ReductiveDevTools.init(devTools$1, Reductive.Store[/* getState */5](store$3));
                  case "ROLLBACK" : 
                      var stateString = unwrap(Caml_option.undefined_to_opt(action$4.state), [
                            StateNotFound$1,
                            "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                          ]);
                      var state$1 = Curry._1(deserializeObject, JSON.parse(stateString));
                      store$3[/* state */0] = state$1;
                      notifyListeners(store$3);
                      meta$2[/* actionCount */2] = 0;
                      return Extension$ReductiveDevTools.init(devTools$1, Reductive.Store[/* getState */5](store$3));
                  case "LOCK_CHANGES" : 
                  case "SWEEP" : 
                      return /* () */0;
                  case "TOGGLE_ACTION" : 
                      var stateString$1 = unwrap(Caml_option.undefined_to_opt(action$4.state), [
                            StateNotFound$1,
                            "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                          ]);
                      if (Belt_Option.isSome(meta$2[/* rewindActionIdx */1]) && Belt_Option.getExn(meta$2[/* rewindActionIdx */1]) >= meta$2[/* actionCount */2] || Belt_Option.isNone(meta$2[/* rewindActionIdx */1])) {
                        var liftedState = JSON.parse(stateString$1);
                        Extension$ReductiveDevTools.send(devTools$1, null, processToogleAction(store$3, payload$2, liftedState, meta$2));
                        return notifyListeners(store$3);
                      } else {
                        return 0;
                      }
                  default:
                    return /* () */0;
                }
                if (exit === 1) {
                  var stateString$2 = unwrap(Caml_option.undefined_to_opt(action$4.state), [
                        StateNotFound$1,
                        "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                      ]);
                  var actionId = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.actionId));
                  var match$1 = actionId === meta$2[/* actionCount */2];
                  meta$2[/* rewindActionIdx */1] = match$1 ? undefined : actionId;
                  var match$2 = meta$2[/* liftedState */0];
                  if (match$2 !== undefined) {
                    var liftedState$1 = Caml_option.valFromOption(match$2);
                    var actionInLiftedStateRange = actionId < liftedState$1.nextActionId;
                    if (actionInLiftedStateRange) {
                      var skippedActions = liftedState$1.skippedActionIds;
                      var computedStates$1 = liftedState$1.computedStates;
                      var nonSkippedIdx = actionId;
                      while(skippedActions.includes(nonSkippedIdx)) {
                        nonSkippedIdx = nonSkippedIdx - 1 | 0;
                      };
                      var targetState$1 = Caml_array.caml_array_get(computedStates$1, nonSkippedIdx).state;
                      var state$2 = Curry._1(deserializeObject, targetState$1);
                      store$3[/* state */0] = state$2;
                    } else {
                      var state$3 = Curry._1(deserializeObject, JSON.parse(stateString$2));
                      store$3[/* state */0] = state$3;
                    }
                  } else {
                    var state$4 = Curry._1(deserializeObject, JSON.parse(stateString$2));
                    store$3[/* state */0] = state$4;
                  }
                  return notifyListeners(store$3);
                }
                case "START" : 
                return /* () */0;
            default:
              return /* () */0;
          }
        }));
  return /* () */0;
}

function defaultOptions(connectionId) {
  return {
          name: connectionId,
          features: {
            pause: true,
            lock: false,
            persist: true,
            export: true,
            import: "custom",
            jump: true,
            skip: false,
            reorder: false,
            dispatch: true
          }
        };
}

function constructOptions(options, defaults) {
  var target = Object.assign(defaults, options);
  return Object.assign(target, {
              serialize: {
                symbol: true
              },
              features: Object.assign(target["features"], {
                    lock: false,
                    reorder: false,
                    export: true,
                    import: "custom"
                  })
            });
}

function reductiveEnhancer(options, storeCreator, reducer, preloadedState, enhancer, param) {
  var targetOptions = constructOptions(options, defaultOptions("ReductiveDevTools"));
  var devTools = Extension$ReductiveDevTools.connect(Extension$ReductiveDevTools.devToolsEnhancer, targetOptions);
  var meta = /* record */Block.record([
      "liftedState",
      "rewindActionIdx",
      "actionCount"
    ], [
      undefined,
      undefined,
      0
    ]);
  var devToolsDispatch = function (store, next, action) {
    var match = meta[/* rewindActionIdx */1];
    if (match !== undefined && match < meta[/* actionCount */2]) {
      return 0;
    } else {
      var store$1 = store;
      var next$1 = next;
      var action$1 = action;
      if (enhancer !== undefined) {
        Curry._3(enhancer, store$1, next$1, action$1);
      } else {
        Curry._1(next$1, action$1);
      }
      meta[/* actionCount */2] = meta[/* actionCount */2] + 1 | 0;
      return Extension$ReductiveDevTools.send(devTools, Curry._2(serializeMaybeVariant, action$1, false), Curry._1(serializeObject, Reductive.Store[/* getState */5](store$1)));
    }
  };
  var store = Curry._4(storeCreator, reducer, preloadedState, devToolsDispatch, /* () */0);
  var actionCreators = targetOptions.actionCreators;
  handle(devTools, store, meta, actionCreators === undefined ? undefined : Caml_option.some(actionCreators));
  return store;
}

function register(connectionId, component, options, param) {
  var targetOptions = options !== undefined ? constructOptions(Caml_option.valFromOption(options), defaultOptions(connectionId)) : defaultOptions(connectionId);
  var devTools = Extension$ReductiveDevTools.connect(Extension$ReductiveDevTools.devToolsEnhancer, targetOptions);
  var actionCreators = targetOptions.actionCreators;
  var connectionInfo = /* record */Block.record([
      "retainedState",
      "connection",
      "meta"
    ], [
      component[/* state */1],
      devTools,
      Block.record([
          "liftedState",
          "rewindActionIdx",
          "actionCount"
        ], [
          undefined,
          undefined,
          0
        ])
    ]);
  connections[connectionId] = connectionInfo;
  var connection = devTools;
  var store = /* record */Block.record([
      "component",
      "connectionId"
    ], [
      component,
      connectionId
    ]);
  var meta = connectionInfo[/* meta */2];
  var actionCreators$1 = actionCreators === undefined ? undefined : Caml_option.some(actionCreators);
  var initialState = getState(store);
  Extension$ReductiveDevTools.init(connection, Curry._1(serializeObject, initialState));
  Extension$ReductiveDevTools.subscribe(connection, (function (action) {
          var match = action.type;
          switch (match) {
            case "ACTION" : 
                var action$1 = action;
                var store$1 = store;
                var actionCreators$2 = actionCreators$1;
                var payload = unwrap(Caml_option.undefined_to_opt(action$1.payload), [
                      PayloadNotFound,
                      "action doesn't contain payload while expected"
                    ]);
                if (actionCreators$2 !== undefined) {
                  return Curry._1(store$1[/* component */0][/* send */3], Curry._2(evalMethod, payload, Caml_option.valFromOption(actionCreators$2)));
                } else {
                  return /* () */0;
                }
            case "DISPATCH" : 
                var action$2 = action;
                var devTools = connection;
                var store$2 = store;
                var initial = initialState;
                var meta$1 = meta;
                var payload$1 = unwrap(Caml_option.undefined_to_opt(action$2.payload), [
                      PayloadNotFound,
                      "action doesn't contain payload while expected"
                    ]);
                var devTools$1 = devTools;
                var store$3 = store$2;
                var payload$2 = payload$1;
                var action$3 = action$2;
                var initial$1 = initial;
                var meta$2 = meta$1;
                var payloadType = payload$2.type;
                var exit = 0;
                switch (payloadType) {
                  case "COMMIT" : 
                      meta$2[/* actionCount */2] = 0;
                      return Extension$ReductiveDevTools.init(devTools$1, getState(store$3));
                  case "IMPORT_STATE" : 
                      var nextLiftedState = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.nextLiftedState));
                      var computedStates = nextLiftedState.computedStates;
                      var targetState = Caml_array.caml_array_get(computedStates, computedStates.length - 1 | 0).state;
                      mutateState(Curry._1(deserializeObject, targetState), store$3);
                      meta$2[/* actionCount */2] = nextLiftedState.nextActionId - 1 | 0;
                      return Extension$ReductiveDevTools.send(devTools$1, null, nextLiftedState);
                  case "JUMP_TO_ACTION" : 
                  case "JUMP_TO_STATE" : 
                      exit = 1;
                      break;
                  case "RESET" : 
                      mutateState(initial$1, store$3);
                      meta$2[/* actionCount */2] = 0;
                      return Extension$ReductiveDevTools.init(devTools$1, getState(store$3));
                  case "ROLLBACK" : 
                      var stateString = unwrap(Caml_option.undefined_to_opt(action$3.state), [
                            StateNotFound,
                            "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                          ]);
                      mutateState(Curry._1(deserializeObject, JSON.parse(stateString)), store$3);
                      meta$2[/* actionCount */2] = 0;
                      return Extension$ReductiveDevTools.init(devTools$1, getState(store$3));
                  case "LOCK_CHANGES" : 
                  case "SWEEP" : 
                  case "TOGGLE_ACTION" : 
                      return /* () */0;
                  default:
                    return /* () */0;
                }
                if (exit === 1) {
                  var stateString$1 = unwrap(Caml_option.undefined_to_opt(action$3.state), [
                        StateNotFound,
                        "action(" + (String(payloadType) + ") doesn\'t contain state while expected")
                      ]);
                  var actionId = Belt_Option.getExn(Caml_option.undefined_to_opt(payload$2.actionId));
                  var match$1 = actionId === meta$2[/* actionCount */2];
                  meta$2[/* rewindActionIdx */1] = match$1 ? undefined : actionId;
                  var match$2 = meta$2[/* liftedState */0];
                  if (match$2 !== undefined) {
                    var liftedState = Caml_option.valFromOption(match$2);
                    var actionInLiftedStateRange = actionId < liftedState.nextActionId;
                    if (actionInLiftedStateRange) {
                      var skippedActions = liftedState.skippedActionIds;
                      var computedStates$1 = liftedState.computedStates;
                      var nonSkippedIdx = actionId;
                      while(skippedActions.includes(nonSkippedIdx)) {
                        nonSkippedIdx = nonSkippedIdx - 1 | 0;
                      };
                      var targetState$1 = Caml_array.caml_array_get(computedStates$1, nonSkippedIdx).state;
                      mutateState(Curry._1(deserializeObject, targetState$1), store$3);
                    } else {
                      mutateState(Curry._1(deserializeObject, JSON.parse(stateString$1)), store$3);
                    }
                  } else {
                    mutateState(Curry._1(deserializeObject, JSON.parse(stateString$1)), store$3);
                  }
                  return /* () */0;
                }
                case "START" : 
                return /* () */0;
            default:
              return /* () */0;
          }
        }));
  return /* () */0;
}

function unsubscribe(connectionId) {
  var connectionInfo = unwrap(Js_dict.get(connections, connectionId), [
        ConnectionNotFound,
        "DevTool connection(id=$connectionId) not found"
      ]);
  Js_dict.unsafeDeleteKey(connections, connectionId);
  return Extension$ReductiveDevTools.unsubscribe(connectionInfo[/* connection */1]);
}

function send(connectionId, action, state) {
  var connectionInfo = unwrap(Js_dict.get(connections, connectionId), [
        ConnectionNotFound,
        "DevTool connection(id=$connectionId) not found"
      ]);
  connectionInfo[/* retainedState */0] = state;
  var exit = 0;
  if (typeof action === "number" || action[0] !== 161605709) {
    exit = 1;
  } else {
    return /* () */0;
  }
  if (exit === 1) {
    return Extension$ReductiveDevTools.send(connectionInfo[/* connection */1], Curry._2(serializeMaybeVariant, action, false), Curry._1(serializeObject, state));
  }
  
}

exports.reductiveEnhancer = reductiveEnhancer;
exports.register = register;
exports.unsubscribe = unsubscribe;
exports.send = send;
/* serializeMaybeVariant Not a pure module */
